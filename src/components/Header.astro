---
import Hamburger from "./Hamburger.astro";
import Navigation from "./Navigation.astro";
import ThemeToggle from "./ThemeToggle.astro";
---

<header class="sticky top-0 z-50 bg-term-bg-light/90 dark:bg-term-bg-dark/90 backdrop-blur-sm border-b border-term-border-light dark:border-term-border transition-colors duration-300 relative overflow-hidden header-binary-wrapper">
  <!-- Binary rain canvas -->
  <canvas id="headerBinaryCanvas" class="absolute inset-0 w-full h-full pointer-events-none opacity-0 transition-opacity duration-500 binary-canvas" aria-hidden="true"></canvas>

  <nav class="container mx-auto flex justify-between items-center py-3 px-6 md:px-8 relative z-10">
    <!-- ターミナルプロンプト風ロゴ -->
    <a href="/" class="flex items-center gap-1 group hover:opacity-90 transition-opacity font-mono font-bold text-lg">
      <span class="text-accent dark:text-accent-light">❯</span>
      <span class="text-gray-800 dark:text-gray-100">tamago.sh</span>
      <span class="inline-block w-2 h-4 bg-accent dark:bg-accent-light align-middle animate-blink ml-0.5 group-hover:opacity-100"></span>
    </a>
    <div class="flex items-center gap-4">
      <div class="hidden md:block">
        <Navigation />
      </div>
      <ThemeToggle />
      <div class="md:hidden">
        <Hamburger />
      </div>
    </div>
  </nav>
  <!-- Mobile nav menu -->
  <div id="mobile-nav" class="hidden md:hidden border-t border-term-border-light dark:border-term-border animate-slide-down relative z-10">
    <div class="container mx-auto px-6 py-4">
      <Navigation />
    </div>
  </div>
</header>

<style>
  .binary-canvas {
    transition: opacity 0.4s ease;
  }

  .header-binary-wrapper:hover .binary-canvas {
    opacity: 1;
  }
</style>

<script>
  const header = document.querySelector('.header-binary-wrapper') as HTMLElement | null;
  const canvas = document.getElementById('headerBinaryCanvas') as HTMLCanvasElement | null;

  if (header && canvas) {
    const ctx = canvas.getContext('2d');
    if (ctx) {
      const FONT_SIZE = 13;
      const CHAR_UPDATE_INTERVAL = 20;
      let columns: number[] = [];
      let chars: string[] = [];
      let frameCount = 0;
      let animFrameId: number | null = null;
      let isHovering = false;

      function resize() {
        const rect = header!.getBoundingClientRect();
        canvas!.width = rect.width;
        canvas!.height = rect.height;
        const colCount = Math.floor(canvas!.width / FONT_SIZE);
        columns = Array.from({ length: colCount }, () => Math.random() * -30);
        chars = Array.from({ length: colCount }, () => Math.random() > 0.5 ? '1' : '0');
      }

      function isDark(): boolean {
        return document.documentElement.classList.contains('dark');
      }

      function draw() {
        if (!ctx || !canvas) return;

        frameCount++;
        const shouldUpdateChar = frameCount % CHAR_UPDATE_INTERVAL === 0;

        const bg = isDark() ? 'rgba(13, 17, 23, 0.18)' : 'rgba(249, 250, 251, 0.18)';
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.font = `${FONT_SIZE}px 'JetBrains Mono', monospace`;

        columns.forEach((y, i) => {
          if (shouldUpdateChar) {
            chars[i] = Math.random() > 0.5 ? '1' : '0';
          }
          const char = chars[i];
          const x = i * FONT_SIZE;
          const progress = y / (canvas!.height / FONT_SIZE);
          const alpha = Math.min(1, 0.15 + progress * 0.6);

          // グリーン系カラー
          ctx.fillStyle = isDark()
            ? `rgba(74, 222, 128, ${alpha})`
            : `rgba(34, 197, 94, ${alpha * 0.65})`;

          ctx.fillText(char, x, y * FONT_SIZE);

          if (y * FONT_SIZE > canvas!.height && Math.random() > 0.975) {
            columns[i] = 0;
          }
          columns[i] += 0.1;
        });

        animFrameId = requestAnimationFrame(draw);
      }

      function startAnimation() {
        if (animFrameId !== null) return;
        resize();
        draw();
      }

      function stopAnimation() {
        if (animFrameId !== null) {
          cancelAnimationFrame(animFrameId);
          animFrameId = null;
        }
        if (ctx && canvas) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        frameCount = 0;
        const colCount = Math.floor((canvas?.width ?? 0) / FONT_SIZE);
        columns = Array.from({ length: colCount }, () => Math.random() * -30);
        chars = Array.from({ length: colCount }, () => Math.random() > 0.5 ? '1' : '0');
      }

      header.addEventListener('mouseenter', () => {
        isHovering = true;
        startAnimation();
      });

      header.addEventListener('mouseleave', () => {
        isHovering = false;
        stopAnimation();
      });

      const resizeObserver = new ResizeObserver(() => {
        if (isHovering) {
          stopAnimation();
          startAnimation();
        } else {
          resize();
        }
      });
      resizeObserver.observe(header);
    }
  }
</script>
